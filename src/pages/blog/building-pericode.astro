---
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<title>Building Pericode: Voice-Controlled Development | Jared Guttromson</title>
		<meta name="description" content="How I built Pericode, a voice-controlled interface for Claude Code that lets developers write code while walking using end-to-end encryption and offline AI models" />

		<!-- Fonts -->
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
	</head>
	<body>
		<nav>
			<div class="nav-container">
				<a href="/" class="logo">
					<img src="/profile.png" alt="JG" class="logo-img" />
				</a>
				<ul class="nav-links">
					<li><a href="/#experience">Experience</a></li>
					<li><a href="/#projects">Projects</a></li>
					<li><a href="/blog">Blog</a></li>
					<li><a href="/#contact">Contact</a></li>
				</ul>
			</div>
		</nav>

		<article class="blog-post">
			<div class="container">
				<header class="post-header">
					<div class="post-meta">
						<time datetime="2025-10-28">October 28, 2025</time>
						<span class="read-time">12 min read</span>
					</div>
					<h1>Pericode: Speech-Based Claude Code Mobile Client</h1>
					<p class="subtitle">Designing a voice-controlled development environment with end-to-end encryption, offline AI models, and global relay infrastructure. Inspired by Aristotle's peripatetic philosophy.</p>
					<div class="tags">
						<span class="tag">Electron</span>
						<span class="tag">SwiftUI</span>
						<span class="tag">End-to-End Encryption</span>
						<span class="tag">Cloudflare Workers</span>
						<span class="tag">Claude Code</span>
					</div>
				</header>

				<div class="post-content">
					<h2>The Vision</h2>
					<p>What if you could write code while walking? Debug during your morning run? Review pull requests on the treadmill? This question led me to build <strong>Pericode</strong>, a voice-controlled interface for Claude Code that lets developers be productive anywhere.</p>

					<p>The name comes from Aristotle's <em>peripatetic</em> school of philosophy, where he taught while walking. The idea: your best thinking often happens when you're moving, not sitting still.</p>

					<p><strong>Website:</strong> <a href="https://pericode.app" target="_blank">pericode.app</a></p>

					<h2>The Challenge: Three Hard Problems</h2>
					<p>Building Pericode meant solving three distinct technical challenges:</p>
					<ol>
						<li><strong>Voice:</strong> What's the best solution that balances cost, privacy, and user experience?</li>
						<li><strong>Context:</strong> How do we give Claude more context to enable tight development loops when not physically at the desk?</li>
						<li><strong>Privacy:</strong> How do you protect sensitive code and conversations when routing through relay servers?</li>
					</ol>

					<h2>Architecture Overview</h2>
					<p>Pericode consists of three components working in harmony:</p>

					<h3>1. Desktop App (Electron)</h3>
					<p>The desktop app runs on your development machine and orchestrates Claude Code agents:</p>
					<ul>
						<li><strong>Multi-agent system:</strong> Spawns Claude Code CLI processes as independent agents</li>
						<li><strong>Real-time streaming:</strong> Parses JSON output from Claude Code and streams to mobile</li>
						<li><strong>Screenshot integration:</strong> MCP (Model Context Protocol) server captures screenshots for visual context</li>
						<li><strong>Tool execution:</strong> Handles bash commands, file edits, and approvals</li>
						<li><strong>Firebase integration:</strong> Session discovery and user authentication</li>
					</ul>

					<h3>2. iOS App (SwiftUI)</h3>
					<p>The mobile app provides a session-based voice interface using cutting-edge offline AI:</p>
					<ul>
						<li><strong>Sherpa-ONNX:</strong> Neural network models for speech recognition and synthesis running entirely on-device</li>
						<li><strong>Sub-second latency:</strong> STT completes in under 1 second, no cloud round-trip</li>
						<li><strong>Privacy-first:</strong> Voice data never leaves your phone</li>
						<li><strong>Session-based interaction:</strong> Start a microphone session to communicate with Claude Code on your desktop</li>
					</ul>

					<h3>3. Relay Server (Cloudflare Workers)</h3>
					<p>A global edge network routes encrypted messages between devices:</p>
					<ul>
						<li><strong>Durable Objects:</strong> Session state maintained at the edge</li>
						<li><strong>~50ms latency:</strong> Messages routed through Cloudflare's global network</li>
						<li><strong>Zero configuration:</strong> No port forwarding or VPN setup needed</li>
						<li><strong>Auto-scaling:</strong> Handles hundreds of concurrent sessions</li>
					</ul>

					<h2>Solving Voice: Cost, Privacy, and UX</h2>
					<p>The voice challenge required balancing three competing factors. Cloud-based services (Google, Azure, AWS) offer great UX but come with recurring costs and privacy concerns. Offline models solve cost and privacy but require careful implementation. Here's why I chose offline:</p>

					<h3>Why Sherpa-ONNX?</h3>
					<p><strong>Sherpa-ONNX</strong> is a neural speech toolkit that runs ONNX models directly on device. The benefits are dramatic:</p>
					<ul>
						<li><strong>Latency:</strong> &lt;1s for STT vs 2-3s for cloud APIs</li>
						<li><strong>Privacy:</strong> Voice never transmitted (critical for coding sessions)</li>
						<li><strong>Cost:</strong> Completely free for unlimited usage (cloud APIs charge $0.006-0.024/min, adding up to $360-1,440/year for 1hr/day usage). For users who prefer cloud-based options, we also support bring-your-own-key for ElevenLabs and OpenAI.</li>
					</ul>

					<p>The trade-off? Model size. The STT model is ~150MB, TTS models ~50MB each. But with modern phone storage, this is negligible compared to the benefits.</p>

					<h2>Solving Privacy: End-to-End Encryption</h2>
					<p>When you're sending code snippets, API keys, and development commands through relay servers, privacy isn't optionalâ€”it's critical. The challenge was implementing bank-level encryption without adding complexity that would slow down the development experience.</p>

					<h3>X25519 + ChaCha20-Poly1305</h3>
					<p>I implemented a complete end-to-end encryption system:</p>

					<p><strong>Key Exchange (X25519 ECDH):</strong></p>
					<ul>
						<li>Desktop generates X25519 keypair, stores in <code>~/.pericode/keys/</code></li>
						<li>iOS generates keypair, stores in Keychain</li>
						<li>Both upload public keys to Firebase Firestore</li>
						<li>Each derives the same shared secret using ECDH (never transmitted!)</li>
					</ul>

					<p><strong>Message Encryption (ChaCha20-Poly1305 AEAD):</strong></p>
					<ul>
						<li>256-bit symmetric encryption</li>
						<li>96-bit random nonces per message</li>
						<li>128-bit authentication tags</li>
						<li>~0.5ms overhead per message</li>
					</ul>

					<p>The result? The relay server sees only encrypted ciphertext. Your code, voice commands, and Claude responses are completely private. This solves the privacy problem: even though messages route through Cloudflare's infrastructure, no one can read your sensitive development data.</p>

					<h3>Security Properties</h3>
					<ul>
						<li><strong>Forward secrecy:</strong> Keys rotate per session</li>
						<li><strong>Authentication:</strong> Firebase prevents session hijacking</li>
						<li><strong>Zero-knowledge relay:</strong> Server cannot decrypt messages</li>
						<li><strong>No key transmission:</strong> ECDH derives shared secret without sending keys over the network</li>
					</ul>

					<h2>The Relay Server Decision</h2>
					<p>For device connectivity, I chose Cloudflare Workers + Durable Objects to create a seamless, zero-configuration experience:</p>

					<h3>Why Cloudflare Workers + Durable Objects?</h3>
					<ul>
						<li><strong>Global edge network:</strong> ~50ms latency from anywhere</li>
						<li><strong>WebSocket routing:</strong> Messages relay between devices automatically</li>
						<li><strong>Session isolation:</strong> Each session in its own Durable Object</li>
						<li><strong>Auto-expiry:</strong> Sessions timeout after inactivity</li>
						<li><strong>Free tier:</strong> Covers hundreds of users</li>
					</ul>

					<p>The ~50ms added latency is imperceptible in practice, and the user experience is dramatically better: just tap a desktop name in the app and connect instantly.</p>

					<h2>Solving Context: Tight Development Loops Away From Your Desk</h2>
					<p>The second challenge was giving Claude enough context to be useful when you're not at your computer. This is where MCP (Model Context Protocol) comes in. By streaming screenshots, file context, and mobile test documentation to the mobile device, Claude can see what you're working on and provide accurate debugging help.</p>

					<h3>Screenshot Streaming via MCP</h3>

					<ul>
						<li><strong>MCP Server:</strong> Desktop runs an MCP server that Claude Code can call</li>
						<li><strong>Multiple capture modes:</strong> Active window, full screen, specific app</li>
						<li><strong>Compression:</strong> Sharp library compresses to &lt;4MB</li>
						<li><strong>Base64 streaming:</strong> Images sent via relay in chunks</li>
						<li><strong>Inline display:</strong> iOS shows thumbnails, tap for full-screen</li>
					</ul>

					<h3>Maestro Documentation Integration</h3>

					<p>For mobile development workflows, I integrated <strong>Maestro</strong> documentation into the context system. Maestro is a cross-platform UI testing framework that works with iOS, Android, React Native, Flutter, SwiftUI, and Jetpack Compose. While this integration is experimental, it's showing promising results. By including Maestro docs in Claude's context:</p>

					<ul>
						<li><strong>Natural language test writing:</strong> Ask Claude to "write a test that logs in and navigates to settings" and it generates valid Maestro YAML</li>
						<li><strong>Framework-agnostic testing:</strong> Works across all mobile frameworks without platform-specific knowledge</li>
						<li><strong>Visual debugging:</strong> Combine screenshots with Maestro test commands for precise mobile UI feedback</li>
						<li><strong>Rapid iteration:</strong> Generate, modify, and run UI tests entirely via voice while away from your desk</li>
					</ul>

					<p>This solves the context problem: when you say "the UI looks broken" while on a walk, Claude can actually see your screen and provide accurate debugging help without you being at your desk. For mobile projects, Claude can also generate Maestro tests to validate the fix.</p>

					<h2>Multi-Agent Orchestration</h2>
					<p>Unlike traditional chatbots, Pericode runs multiple Claude Code agents simultaneously:</p>

					<ul>
						<li><strong>Agent lifecycle:</strong> Each agent is a spawned child process</li>
						<li><strong>Independent execution:</strong> Agents don't block each other</li>
						<li><strong>Project isolation:</strong> Agents grouped by directory</li>
						<li><strong>Conversation history:</strong> Each agent maintains its own context</li>
						<li><strong>Streaming output:</strong> Real-time updates via JSON parsing</li>
					</ul>

					<p>You can have one agent refactoring your authentication module while another runs tests, and a third reviews your PR. All controlled by voice.</p>

					<h2>Tool Approval Workflow</h2>
					<p>Giving an AI full access to bash commands and file edits is dangerous. I built an approval system:</p>

					<ul>
						<li><strong>SwiftUI sheet:</strong> Beautiful approval UI on iOS</li>
						<li><strong>Tool details:</strong> Shows command, description, and parameters</li>
						<li><strong>Push notifications:</strong> Fallback if app is backgrounded</li>
						<li><strong>Auto-approve option:</strong> For trusted use cases</li>
					</ul>

					<p>Example: Claude wants to run <code>npm install</code>. You get a notification, review the command, approve or deny. If denied, Claude continues without that tool.</p>

					<h2>What's Next</h2>
					<p>Pericode is currently in private beta with plans for public release soon. The next phase focuses on:</p>

					<ul>
						<li><strong>Public release:</strong> Opening up Pericode to all developers</li>
						<li><strong>Template projects:</strong> Pre-configured starter projects across different frameworks (React Native, Flutter, SwiftUI) that work out of the box with Pericode, complete with MCP server setup, screenshot tools, and Maestro integration for immediate voice-controlled development</li>
						<li><strong>Maestro integration:</strong> MCP tools for mobile UI testing and automation, enabling Claude to understand and interact with mobile app flows through natural language commands</li>
						<li><strong>Screenshot feedback MCP:</strong> Advanced screenshot analysis tools specifically designed for mobile development, allowing Claude to provide detailed UI/UX feedback and catch visual regressions during voice-based development sessions</li>
					</ul>

					<h2>Conclusion</h2>
					<p>Building Pericode taught me that the best developer experiences come from solving multiple hard problems well:</p>

					<ul>
						<li><strong>Cost matters:</strong> Offline AI models eliminate recurring voice API costs</li>
						<li><strong>Security is non-negotiable:</strong> E2E encryption is table stakes for code tools</li>
						<li><strong>UX > technical elegance:</strong> Relay servers beat VPN in practice</li>
						<li><strong>Simplicity wins:</strong> Session-based voice interaction keeps the experience focused</li>
					</ul>

					<p>Most importantly: sometimes your best code happens when you're not at your desk. Pericode is my attempt to make that a reality.</p>

					<p><strong>Website:</strong> <a href="https://pericode.app" target="_blank">pericode.app</a></p>
				</div>
			</div>
		</article>

		<style>
			:root {
				--bg-primary: #ffffff;
				--bg-secondary: #f8fafc;
				--text-primary: #1e293b;
				--text-secondary: #64748b;
				--accent: #2563eb;
				--accent-hover: #1e40af;
				--border: #e2e8f0;
			}

			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
				background: var(--bg-primary);
				color: var(--text-primary);
				line-height: 1.7;
			}

			/* Navigation */
			nav {
				background: var(--bg-secondary);
				border-bottom: 1px solid var(--border);
				position: sticky;
				top: 0;
				z-index: 100;
				backdrop-filter: blur(10px);
			}

			.nav-container {
				max-width: 1200px;
				margin: 0 auto;
				padding: 1.5rem 2rem;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.logo {
				text-decoration: none;
			}

			.logo-img {
				width: 40px;
				height: 40px;
				border-radius: 50%;
			}

			.nav-links {
				display: flex;
				gap: 2rem;
				list-style: none;
			}

			.nav-links a {
				color: var(--text-secondary);
				text-decoration: none;
				transition: color 0.2s;
			}

			.nav-links a:hover {
				color: var(--accent);
			}

			/* Blog Post */
			.blog-post {
				max-width: 800px;
				margin: 0 auto;
				padding: 4rem 2rem;
			}

			.post-meta {
				display: flex;
				gap: 1rem;
				color: var(--text-secondary);
				font-size: 0.9rem;
				margin-bottom: 1rem;
			}

			.post-header h1 {
				font-size: 3rem;
				font-weight: 800;
				line-height: 1.2;
				margin-bottom: 1rem;
			}

			.subtitle {
				font-size: 1.25rem;
				color: var(--text-secondary);
				margin-bottom: 1.5rem;
			}

			.tags {
				display: flex;
				flex-wrap: wrap;
				gap: 0.5rem;
				margin-bottom: 3rem;
			}

			.tag {
				background: var(--bg-secondary);
				color: var(--accent);
				padding: 0.5rem 1rem;
				border-radius: 20px;
				font-size: 0.85rem;
				border: 1px solid var(--border);
			}

			.post-content {
				font-size: 1.1rem;
			}

			.post-content h2 {
				font-size: 2rem;
				font-weight: 700;
				margin: 3rem 0 1.5rem;
				color: var(--text-primary);
			}

			.post-content h3 {
				font-size: 1.5rem;
				font-weight: 600;
				margin: 2rem 0 1rem;
				color: var(--text-primary);
			}

			.post-content p {
				margin-bottom: 1.5rem;
				color: var(--text-secondary);
			}

			.post-content ul,
			.post-content ol {
				margin-bottom: 1.5rem;
				padding-left: 1.5rem;
				color: var(--text-secondary);
			}

			.post-content li {
				margin-bottom: 0.5rem;
			}

			.post-content code {
				background: var(--bg-secondary);
				color: var(--accent);
				padding: 0.2rem 0.4rem;
				border-radius: 4px;
				font-size: 0.9em;
				font-family: 'SF Mono', 'Monaco', monospace;
			}

			.post-content a {
				color: var(--accent);
				text-decoration: none;
			}

			.post-content a:hover {
				color: var(--accent-hover);
				text-decoration: underline;
			}

			.post-content table {
				width: 100%;
				border-collapse: collapse;
				margin: 2rem 0;
				background: var(--bg-secondary);
				border-radius: 8px;
				overflow: hidden;
			}

			.post-content th,
			.post-content td {
				padding: 1rem;
				text-align: left;
				border-bottom: 1px solid var(--border);
			}

			.post-content th {
				background: var(--bg-primary);
				font-weight: 600;
				color: var(--text-primary);
			}

			.post-content td {
				color: var(--text-secondary);
			}

			.post-content strong {
				color: var(--text-primary);
				font-weight: 600;
			}

			.post-footer {
				margin-top: 4rem;
				padding-top: 2rem;
				border-top: 1px solid var(--border);
			}

			.author-info {
				display: flex;
				gap: 1rem;
				align-items: center;
				margin-bottom: 2rem;
			}

			.author-avatar {
				width: 60px;
				height: 60px;
				border-radius: 50%;
			}

			.author-details strong {
				display: block;
				margin-bottom: 0.25rem;
			}

			.author-details p {
				color: var(--text-secondary);
				font-size: 0.9rem;
				margin: 0;
			}

			.share-links {
				display: flex;
				gap: 1rem;
			}

			.share-links a {
				padding: 0.75rem 1.5rem;
				background: var(--bg-secondary);
				border: 1px solid var(--border);
				border-radius: 8px;
				text-decoration: none;
				color: var(--text-secondary);
				transition: all 0.2s;
			}

			.share-links a:hover {
				background: var(--accent);
				color: white;
				border-color: var(--accent);
			}

			@media (max-width: 768px) {
				.post-header h1 {
					font-size: 2rem;
				}

				.subtitle {
					font-size: 1.1rem;
				}

				.nav-links {
					gap: 1rem;
					font-size: 0.9rem;
				}

				.post-content {
					font-size: 1rem;
				}

				.blog-post {
					padding: 2rem 1.5rem;
				}
			}
		</style>
	</body>
</html>
